[{"title":"Extensions","type":0,"sectionRef":"#","url":"docs/extensions","content":"Extensions Out of the box, providers do not do much. Developers can add whatever they want to providers, but that can get clunky very quickly. Many times, there are repeated patterns that are desired in providers. To avoid the need of a lot of copy-and-pasted code, extensions can be used to extend the capabilities of providers. TODO: Add examples of extensions and clean up the above paragraph.","keywords":""},{"title":"Axis","type":0,"sectionRef":"#","url":"api/Axis","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Axis","url":"api/Axis#types","content":" "},{"title":"Provider​","type":1,"pageTitle":"Axis","url":"api/Axis#Provider","content":"&lt;/&gt; interface Provider { AxisName: string? AxisPrepare: (Provider) → () AxisStarted: (Provider) → () } Providers are simple structures that provide top-level structure, as well as lifecycle methods to help safeguard communication between each other.  "},{"title":"Extension​","type":1,"pageTitle":"Axis","url":"api/Axis#Extension","content":"&lt;/&gt; interface Extension { BeforePrepare: (Provider) → () BeforeStarted: (Provider) → () } Extensions allow developers to extend the capabilities of providers within Axis. "},{"title":"Functions​","type":1,"pageTitle":"Axis","url":"api/Axis#functions","content":" "},{"title":"AddExtension​","type":1,"pageTitle":"Axis","url":"api/Axis#AddExtension","content":"&lt;/&gt; Axis:AddExtension(extension: Extension) → Extension Add an extension to Axis. Extensions will run before certain lifecycle methods per provider. Extensions are useful for extending the capabilities of providers. Here's an example of logging when a provider is about to be prepared and started: local MyExtension = {} -- Note the dot-notation for functions instead of colon-notation function MyExtension.BeforePrepare(provider) print(&quot;BeforePrepare provider&quot;, provider.AxisName) end function MyExtension.BeforeStarted(provider) print(&quot;BeforeStarted provider&quot;, provider.AxisName) end Axis:AddExtension(MyExtension) Extensions can also be added at the provider level. This is useful if an extension shouldn't apply to all other providers. Adding extensions at the provider level is done by adding an extension into the provider'sAxisExtension table: local MyProvider = {} MyProvider.AxisExtensions = {MyExtension} Extensions are executed in the order of which they were added. Axis-level extensions run before provider-level extensions. Before Start Must be called before Axis:Start().  "},{"title":"AddProvider​","type":1,"pageTitle":"Axis","url":"api/Axis#AddProvider","content":"&lt;/&gt; Axis:AddProvider(provider: Provider) → Provider Add a provider to Axis. local MyProvider = {} -- Optional name for memory labeling: MyProvider.AxisName = &quot;MyProvider&quot; -- AxisPrepare is called and completed on all providers before moving -- on to AxisStarted: function MyProvider:AxisPrepare() print(&quot;Prepare MyProvider here&quot;) end -- AxisStarted is called once all AxisPrepare methods have completed: function MyProvider:AxisStarted() print(&quot;Axis started&quot;) end -- Add the provider to Axis: Axis:AddProvider(MyProvider) Before Start Must be called before Axis:Start().  "},{"title":"Start​","type":1,"pageTitle":"Axis","url":"api/Axis#Start","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Axis:Start() → () Starts Axis and yields the current thread until Axis has fully started. -- [Add providers/extensions here before starting] Axis:Start() print(&quot;Axis has started&quot;) Call Once Can only be called once. Calling more than once will throw an error. Yields Only If Necessary If any of the AxisPrepare or BeforePrepare functions yield, Axis will yield to wait for them to complete. If none yield, then Axis will start immediately without any yield.  "},{"title":"AwaitStart​","type":1,"pageTitle":"Axis","url":"api/Axis#AwaitStart","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Axis:AwaitStart() → () Yields the current thread until Axis has fully started. If Axis has already been started, this function simply does nothing. Axis:AwaitStart() print(&quot;Axis has started!&quot;)   "},{"title":"OnStart​","type":1,"pageTitle":"Axis","url":"api/Axis#OnStart","content":"&lt;/&gt; Axis:OnStart(callback: () → ()) → () Calls the callback once Axis has fully started. If Axis has already been started, then the callback is immediately called. Axis:OnStart(function() print(&quot;Axis has started!&quot;) end)  "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"docs/intro","content":"Getting Started Axis is a provider framework for the Roblox ecosystem. Providers are simple structures that provide high-level encapsulation of logic, along with lifecycle methods to help accommodate communication between each other. A provider in its simplest form may look like this: local MyProvider = {} function MyProvider:AxisPrepare() end function MyProvider:AxisStarted() end return MyProvider Copy To add a provider to Axis, call the AddProvider method: Axis:AddProvider(MyProvider) Copy Because providers are just Lua tables, developers can add any desired methods and functionality to them as needed. The two AxisPrepare and AxisStarted methods are lifecycle methods that Axis will call during startup. AxisPrepare is called first, and should be used to prepare the provider for use. AxisStarted is called after all other providers have completed their AxisPrepare methods. At this point, it is safe to assume that other providers can be used from within a provider. Typically, there will be one script per server/client that will gather all providers and extensions, and then add them to Axis. Once all providers and extensions are added, Axis can be started.","keywords":""},{"title":"Providers","type":0,"sectionRef":"#","url":"docs/providers","content":"","keywords":""},{"title":"Making it useful​","type":1,"pageTitle":"Providers","url":"docs/providers#making-it-useful","content":"Providers are just tables. As such, developers can add whatever is desired to a provider table. For instance, here is an example of a provider that does simple math: local MathProvider = {} function MathProvider:AxisPrepare() end function MathProvider:AxisStarted() end function MathProvider:Add(n1: number, n2: number): number return n1 + n2 end Copy And now other code can call the provider: local result = MathProvider:Add(10, 20) print(result) --&gt; 30 Copy Of course, a module like above could exist as a standalone ModuleScript without any need to be a provider. Providers are usually more complex systems that benefit from being contained. For instance, there could be a provider that handles player data. "},{"title":"Access a provider from another provider​","type":1,"pageTitle":"Providers","url":"docs/providers#access-a-provider-from-another-provider","content":"It is common for one provider to use another. As stated earlier, providers are just tables. As such, there is no trickery in using one provider from another. Simply reference the provider table and use it as desired. However, providers should respect the lifecycle methods. Providers should not access other providers until the AxisStarted method has been called. local AnotherProvider = require(somewhere.AnotherProvider) -- Get the other provider local MyProvider = {} function MyProvider:AxisPrepare() -- Not safe to use AnotherProvider because we can't guarantee it is ready yet end function MyProvider:AxisStarted() -- We can now guarantee that AnotherProvider:AxisPrepare() has been called and completed. -- It is now safe to use AnotherProvider. AnotherProvider:DoSomething() end return MyProvider Copy "},{"title":"Avoid Strong Coupling​","type":1,"pageTitle":"Providers","url":"docs/providers#avoid-strong-coupling","content":"Coupling occurs when pieces of code require other pieces of code. Such dependencies are unavoidable in many use-cases. However, providers are designed to be top-level singletons. As such, they should be design as standalone as possible. While there are definitely cases where providers will need to access other providers (hence the lifecycle methods existing in the first place), it is better to design around such necessities. "}]